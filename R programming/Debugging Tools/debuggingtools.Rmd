---
title: "Debugging Tools - Diagnosing the Problem"
author: "David Asare Kumi"
date: "10/31/2019"
output: html_document
---


## Debugging

- They can be useful for figuring out what's wrong after you have discovered a problem.

- Something is wrong! Indication that something is not right.

- Message: A generic notification/diagnostic message produced by the message function; execution of the function continues.

- Warning: An indication that something is wrong but not necessarily fatal; execution of the function continues; generated by the warning function.

- error: An indication that a fatal problem has occured; execution stops; produced by the stop function.

- Condition: A generic concept for indicating that something unexpected can occur; programmers can create their own conditions.

- There are three main types of indications.

1. Message.

2. Warning; messages after execution.

3. Error: execution stops. Produced by the stop function.

4. Conditions: all the three types are conditions. You can also create your own condition.

### Warning

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
log(-1)

```

- warning message: In log(-1); NaNs produced. This warning occurs after the execution.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
printmessage <-function(x){
  if (x>0)
    print("x is greater than zero")
  else
    print("x is less than or equal to zero")
  invisible(x)
}

```

- Invisible prevents auto printing e.g. of invisible function is the load function. The object that is returned does not get printed to the console.

- All print functions will return the string that it prints.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
printmessage(1)

```

- printmessage(NA). Error in if (x > 0): missing value where TRUE/FALSE needed.

- Let's fix this function.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
printmessage2 <-function(x){
  if(is.na(x))
    print("x is a missing value!")
  else if(x>0)
    print("x is greater than zero")
  else
    print("x is less than or equal to zero")
  invisible(x)
}
printmessage2(NA)

```

### Something is Wrong

- How do you know that something is wrong with your function?

- What was your input? How did you call the function?

- What were you expecting? Output, messages, other results?

- What did you get?

- How does what you get differ from what you were expecting?

- Were your expectations correct in the first place?

- Can you reproduce the problem(exactly)?

- We ask all these questions when you are asking for help.

### Problems that are hard to reproduce

- Writing networking functions.

- If you are getting data from the internet.

## Debugging Tools - Basic Tools

- Debugging Tools in R; The primary tools for debugging functions in R are;

- traceback: prints out the function call stack after an error occurs; does nothing if there is no error.

- debug; flags a function for debug mode which allows you to step through execution of a function one line at a time.

- browser; suspends the execution of a function wherever it is called and puts the function in debug mode. browser is related to debug.

- trace; allows you to insert debugging code into a function at specific places.

- recover; allows you to modify the error behaviour so that you can browse the function call stack. recover is related to traceback.

- These are interactive tools specifically designed to allow you to pick through a function.

- There is also the more blunt technique of inserting print/cat statements in the function.

- Some people believe that using the debugger is a bad habit.

## Debugging Tools - Using the tools

### traceback

- mean(x). Error in mean(x): object "x" not found.

- traceback(). call traceback immediately after the error occurs. traceback occurs at the top level.

- lm(y~x). Error in eval(expr,envir,enclos): object y not found.

- traceback(). call traceback immediately.

- You can track these errors effectively when using the base r console and not rstudio.

### debug

- debug(lm).

- lm(y~x).

- debug prints out the entire code of the function. Check this out from the base r console.

- browser is just like a workspace embedded in a workspace.

- How to leave the R browser() in the console window. Enter f press enter and then enter Q. The order is finish and then quit. Otherwise you might not leave the browsing.

### recover

- Set the recover function.

- options(error=recover).

- read.csv("nosuchfile").

- Error in file (file,"rt"): cannot open the connection. In addition: warning message message: In file (file,"rt"): cannot open file 'nosuchfile':No such file or directory.

- Enter a frame number, or 0 to exit.

## Debugging

### Summary

- There are three(3) main indications of a problem/condition:

1. message.

2. warning.

3. error.

- Only an error is fatal.

- When analyzing a function with a problem, make sure you can reproduce the problem, clearly state your expectations, and how the output differs from your expectations.

- Interactive debugging tools traceback, debug, browser, trace and recover can be used to find problematic code in functions.

- Debugging tools are not a substitute for thinking!

## Profiler - Part 1

- Why is my code so slow? Profiling is a systematic way to determine how much time is spent in different parts of a program.

- Useful when trying to optimize your code.

- Often code runs fine once, but what if you have to put it in a loop for 1000 iterations? Is it still fast enough?

- Profiling is better than guessing.

## On optimizing your code

- Getting biggest impact on speeding up code depends on knowing where the code spends most of its time.

- This cannot be done without performance analysis or profiling.

- We should forget about small efficiencies, say about 97% of the time; premature optimization is the root of all evil - Donald Knuth.

- The first thing to think about is;

1. How to get your code to run.

2. How to make your code readable.

3. How to make sure that other people can understand what you doing.

- Performance analysis or profiling will help you know the time spent in different parts of your program.

## General Principles of Optimization

- Design first, then optimize.

- Remember: Premature optimization is the root of all evil.

- Measure (collect data), don't guess.

- If you're going to be scientist, you need to apply the same principles here!

- If you try to optimize first, the chances are that you introduce bugs.

- The way you collect the data is by profiling.

## Using System.time()

- This is the first tool to talk about.

- Takes an arbitrary R expression as input (can be wrapped in curly braces) and returns the amount of time taken to evaluate the expression.

- Computes the time (in seconds) needed to execute an expression. If there is an error, gives time until the error occured.

- Returns an object of class proc_time.

1. User time: time charged to the CPU(s) for this expression (time the computer experiences).

2. Elapsed time: "Wall Clock" time (Time that you experience).

- Usually, the usertime and elapsed time are relatively close, for straight computing tasks.

- Elapsed time may be greater than user time if the CPU spends a lot of time waiting around.

- Elapsed time may be smaller than user time if your machine has multiple cores/processors (and is capsble of using them).

- Multi-threaded BLAS libraries (VecLib/Accelerate, ATLAS, ACML, MKL).

- Parallel processing via the parallel package.

- Elapsed time > User time. Here, the CPU may not be working on your code first but may be working on other things at the background.

- The basic R does not use multiple cores. However it is linked to libraries that use multiple cores e.g. linear algebra libraries.

## Using system.time() function

- Elapsed time > User time.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
system.time(readLines("http://www.jhsph.edu"))

```

- Elapsed time < User time.

- Timing longer expressions. You can time longer expressions by wrapping everything in a set of curly braces.

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
system.time({
  n <-1000
  r <-numeric(n)
  for(i in 1:n){
    x <-rnorm(n)
    r[i] <-mean(x)
  }
})

```

- Here we note that user time and elapsed time are basically the same.

## Beyond system.time() function

- Using system.time allows you to test certain functions or code blocks to see if they are taking excessive amounts of time.

- Assumes you already know where the problem is and can call system.time() on it.

- What if you don't know where to start.

## R Profiler - Part 2

###  The R profiler

- The Rprof() function starts the profiler in R.

- R must be compiled with profiler support (but this is usually the case).

- The summary Rprof() function summarizes the output from Rprof() (other-wise it's not readable).

- Do not use system.time() and Rprof() together or you will be sad.

- Rprof() function keeps track of the function call stack at regularly sampled intervals and tabulates how much time is spent in each function.

- Default sampling interval is 0.02 seconds.

- NOTE: If your code runs very quickly, the profiler is not useful, but then you probably don't need it in that case.

- If your function takes less than 0.02 seconds to run, then your Rprofiler will not be needed (profiler will be useless).

## Using summaryRprof() function

- The summary Rprof() function tabulates the R profiler output and calculates how much time is spent in which function.

- There are two methods for normalizing the data.

- "by.total" divides the time spent in each function by the total runtime.

- "by.self" does the same but first subtracts out time spent in functions above in the call stack.

- Normalizing "by total" and "by self".

- by total: how many times the function appears in the print out.

- The top level functions call helper functions. Subract all the lower level functions and this is the by.self format. This gives a more accurate picture.

### By total output

- $by.total: the output gives you total.time , total.pct , self.time , self.pct.

### By self output

- $by.self: the output gives you self.time , self.pct , total.time , total.pct.

### summaryRprof() output

- $sample.interval

- $sample.time

## Summary

- Rprof() runs the profiler for performance of analysis of R code.

- summaryRprof() summarizes the output of Rprof() and gives percent of time spent in each function(with two types of normalization).

- Good to break your code into functions so that the profiler can give useful information about where time is being spent.

- C or Fortran code is not profiled.[ C or Fortran is like a black path].

## Attach and Detach

- We use the attach() function on a dataframe when we want to render each variable(column) of the dataframe as independent so that you can work directly with that variable without regard to the dataframe.

- When done, use the detach() function to revert to the normal dataframe. The detach() function renders the variables(columns) in the data frame as dependent. You cannot do anything with the columns directly without regard to the dataframe.

### Example

```{r,echo=TRUE,message=FALSE,warning=FALSE,comment=""}
library(datasets)
library(dplyr)
data(airquality)
dim(airquality)
names(airquality)
glimpse(airquality)
attach(airquality)
hist(Ozone,col="yellow")
hist(Solar.R,col="yellow")
hist(Wind,col="yellow")
hist(Temp,col="yellow")
detach(airquality)

```

